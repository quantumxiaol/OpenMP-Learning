# 归并排序

使用归并排序的方法对vector<int>进行排序。比较普通归并排序、多线程归并排序和算法库排序函数std::sort的性能差异。

## 初始化vector<int>

使用多线程的方式初始化了一个整数向量，每个线程负责向量的一部分，并且每个线程都有独立的随机数生成器以确保线程间的独立性和线程安全。

使用 std::uniform_int_distribution 来生成介于0到100000之间的随机整数。
    
Main：使用本地时间作为种子初始化随机数生成器,为每个线程创建独立的随机数生成器,为每个生成器设置不同的种子。


# 归并排序原理

归并排序是一种分治算法，它通过递归地将数组分成两半，直到每个子数组只包含一个元素，然后再将这些子数组合并成有序数组。

归并排序的主要步骤如下：

分解：将数组分成两半，递归地对左半部分和右半部分进行归并排序。

合并：将两个有序的子数组合并成一个有序数组。

合并步骤时，初始化两个指针，分别指向两个有序子数组的开始位置。
比较两个子数组当前指针所指向的元素，将较小的元素放入结果数组中，并移动对应的指针。
重复此过程，直到一个子数组的所有元素都被放入结果数组。
将另一个子数组剩余的元素依次放入结果数组。


分解过程

    void mergeSort(std::vector<int>& vec, int left, int right) {
        if (left >= right) {
            return; // 递归终止条件
        }
    
        int mid = left + (right - left) / 2;
    
        // 递归排序左右子向量
        mergeSort(vec, left, mid);
        mergeSort(vec, mid + 1, right);
    
        // 合并两个子向量
        merge(vec, left, mid, right);
    }

可以采用插入排序排序较短数组。


# 多线程归并排序原理

多线程归并排序是在归并排序的基础上增加了多线程的支持，以提高排序效率。主要思路是利用多核处理器的优势，通过并行地处理数组的不同部分来加速排序过程。

多线程归并排序的主要步骤如下：

分解：将数组分成两半，然后创建两个线程分别对左右两半进行归并排序。

合并：将两个有序的子数组合并成一个有序数组。

使用 OpenMP 实现多线程归并排序

使用 #pragma omp parallel for 创建并行区域，允许循环中的迭代任务被不同线程并行执行。
在并行区域内部，通过递归调用 mergeSort_MT 函数来并行处理左右子数组。
最终，使用 merge 函数将两个有序的子数组合并成一个有序数组。


# std::sort 原理

std::sort 是 C++ 标准库中的一个通用排序函数，它提供了一种高效的方式来排序容器中的元素。std::sort 实际上是基于快速排序算法的变种，称为 Introsort 或 Introselect，这是一种混合排序算法，它结合了快速排序、堆排序和插入排序的优点。

Introsort 的主要步骤如下：

快速排序：首先使用快速排序算法进行排序。

检测性能退化：如果快速排序的递归深度超过了预设的阈值，说明快速排序可能遇到了最坏情况（例如，数组已经是部分排序的情况），这时会切换到堆排序。

堆排序：使用堆排序完成排序，以保证 O(n log n) 的最坏情况时间复杂度。

插入排序：对于小数组，使用插入排序进行优化，因为它在小数组上通常比快速排序和堆排序更快。

使用chrono对比不同版本的运行时间。
